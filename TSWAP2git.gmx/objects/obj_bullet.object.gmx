<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize variables


bullet_distance=1;
bullet_origin_id=noone;
bullet_origin_speed=0;
bullet_target_id=noone;
bullet_target_speed=0;
bullet_current_speed=-1;
bullet_movement_speed=1;


image_speed=0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Move the bullet

// Bullet movement
if (bullet_target_speed&gt;0) { // this is a swap
    var bullet_speed_difference=bullet_target_speed-bullet_origin_speed; // difference between target_speed and origin_speed
    var bullet_speed_minimum=min(bullet_target_speed,bullet_origin_speed); // minimum speed value
    var bullet_speed_duration=bullet_distance/(mean(bullet_target_speed,bullet_origin_speed)*60*bullet_movement_speed); // duration in seconds CORRECTED FOR EASING
    if (bullet_current_speed&lt;0) { // if still create value of -1 then
        bullet_current_speed=max(0.1,sign(-1*bullet_speed_difference));
        if (bullet_current_speed=1) {
            image_index=1;
        }
    }
    easing_array=scr_easing(bullet_current_speed,bullet_speed_duration,sign(bullet_speed_difference),true);
    bullet_current_speed=easing_array[0];
    collision_array=scr_collision(x,y,direction,bullet_movement_speed*((easing_array[1]*abs(bullet_speed_difference))+bullet_speed_minimum),1,true);
    
    // change image_alpha depending on distance left
    easing_array=scr_easing(image_alpha,bullet_speed_duration,false,false);
    image_alpha=easing_array[0]; // control image alpha with a easeOutCubic deceleration


} else { // simple &amp; follow bullet movement
    // default speed settings modified by delta
    collision_array=scr_collision(x,y,direction,bullet_movement_speed*delta,1,false);
    bullet_target_id=collision_array[3];
}


// Update the bullet
x=collision_array[0];
y=collision_array[1]; // update x,y values
direction=collision_array[2]; // set new direction if required
image_angle=direction; // update image_angle if required
bullet_distance-=collision_array[4]; // subtract moved distance in pixels from total


// Bullet death
if (bullet_target_speed&gt;0) { // this is a swaptype bullet
    if (bullet_distance&lt;=0) { // all swaps die when distance is done
        // swap death halfway or fullway
        instance_destroy();
    }
} else if (bullet_distance&lt;=0) {
    // run out of juice for bullet just die
    instance_destroy();
} else if (bullet_target_id!=noone) { // if hitting something this shouldnt be a swap
    if (bullet_target_speed&lt;=0) { // let's make double sure in case code changes
        with (bullet_target_id) {
            with (other) {
                // explosion effects here for normal hits on contact
                if (image_index&gt;image_number-2) {
                    instance_destroy();
                }
                image_speed=.1*delta; // 6 frames per second  die on last frame
                bullet_movement_speed=0; // prevent further movement
            }
        }
    } 
}


if (bullet_movement_speed==0) { // if movement speed is 0 only possible when target was hit
    if (bullet_target_id!=noone) { // double check just in case
        instance_destroy();
        exit; // Woah lets see if this feature works even if it doesn't no-one is harmed. except for a forever floating bullet
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();
draw_text(x,y,"move:"+string(bullet_current_speed)+
              "#spd:"+string(bullet_origin_speed)+"/"+string(bullet_target_speed));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
